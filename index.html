<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="You have a dream, you gotta to protect it.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sylar&#39;s Notes">
<meta property="og:url" content="http://www.hhhhyf.com/index.html">
<meta property="og:site_name" content="Sylar&#39;s Notes">
<meta property="og:description" content="You have a dream, you gotta to protect it.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sylar&#39;s Notes">
<meta name="twitter:description" content="You have a dream, you gotta to protect it.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.hhhhyf.com/"/>





  <title>Sylar's Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sylar's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/11/08/c-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/c-11/" itemprop="url">c++11/14学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T15:39:43+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.gitbook.com/book/changkun/cpp1x-tutorial/details" target="_blank" rel="external">学习资料</a></p>
<h1 id="c-的特性"><a href="#c-的特性" class="headerlink" title="c++的特性"></a>c++的特性</h1><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>之前的NULL，有时候编译器会为((void*)0),有的会定义为0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char *Ch = NULL;</div><div class="line">void foo(char *);</div><div class="line">void foo(int);</div></pre></td></tr></table></figure></p>
<p>这种情况。因为NULL被定义0了，调用foo(CH)重载就调用foo(int)了，就会产生未知的错误。</p>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>这玩意就是显示声明函数或者构造函数为常数，在编译的时候就告诉编译器，函数xxx是一个常量。感觉用在递归函数啊什么的，提高性能的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">constexpr int fibonacci(const int n) &#123;</div><div class="line">if(n == 1) return 1;</div><div class="line">if(n == 2) return 1;</div><div class="line">return fibonacci(n-1)+fibonacci(n-2);</div></pre></td></tr></table></figure></p>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>自动推导类型，我一般都用在那种模板里面很长的变量的定义，不能用在函数参数推导，数组类型推导。</p>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype(表达式) 和auto配合使用，推导出表达式的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto x = 1;</div><div class="line">auto y = 2;</div><div class="line">decltype(x+y) z;</div></pre></td></tr></table></figure></p>
<p>在模板中使用，得到返回类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//c11</div><div class="line">template&lt;typename T, typename U&gt;</div><div class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</div><div class="line">return x+y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//c14后可以直接</div><div class="line">template&lt;typename T, typename U&gt;</div><div class="line">auto add(T x, U y) &#123;</div><div class="line">return x+y</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(auto &amp;i: array)</div><div class="line">&#123;</div><div class="line">    std:count &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>之前只有那些结构体啊，数组可以用{}进行初始化。但是类就只能通过构造函数。<br>以前初始化一个容器需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int a[] = &#123;0, 1, 2, 3&#125;;</div><div class="line">std:vector&lt;int&gt; vec(a, a+sizeof(a));</div><div class="line">//或者</div><div class="line">vec.push_back(0);</div><div class="line">vec.push_back(1);</div><div class="line">vec.push_back(2);</div><div class="line">vec.push_back(3);</div><div class="line"></div><div class="line">//现在直接</div><div class="line">std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h3><p>之前模板只在使用的时候被实例化，就是碰到了完整定义的模板都会实例化。c11加入了外部模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template class std::vector&lt;MagicClass&gt;; // 强行实例化</div><div class="line">extern template class std::vector&lt;MagicClass&gt;; // 不在该编译文件中实例化</div></pre></td></tr></table></figure></p>
<h3 id="using-类型别名"><a href="#using-类型别名" class="headerlink" title="using 类型别名"></a>using 类型别名</h3><p>和typedef 一样，但是还可以定义与模板的类型名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int (*process)(void *); // 定义了一个返回类型为 int，参数为</div><div class="line">void* 的函数指针类型，名字叫做 process</div><div class="line">using process = void(*)(void *); // 同上, 更加直观</div><div class="line">using NewType = SuckType&lt;std::vector, std::string&gt;;</div></pre></td></tr></table></figure></p>
<h3 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T = int, typename U = int&gt;</div><div class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</div><div class="line">return x+y</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h3><p><code>template&lt;typename... Args&gt; class Test</code></p>
<p>递归解包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">template&lt;typename T&gt;</div><div class="line">void printf(T value) </div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line">template&lt;typename T, typename... Args&gt;</div><div class="line">void printf(T value, Args... args)</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</div><div class="line">    printf(args...);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    printf(1, 2, &quot;123&quot;, 1.1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h2><p>同一个类里面一个构造函数调用另外一个构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Base </div><div class="line">&#123;</div><div class="line"></div><div class="line">Base() &#123; value1 = 1; &#125;</div><div class="line">Base(int value) : Base()</div><div class="line">&#123; // 委托 Base() 构造函数</div><div class="line">    value2 = 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public:</div><div class="line">    int value1;</div><div class="line">    int value2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Subclass : public Base</div><div class="line"> &#123;</div><div class="line">public:</div><div class="line">    using Base::Base; // 继承构造</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>当重载虚函数时，override会显示告知编译器检查父类有没有这样的函数，没有会编译不过。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final 防止被继承的函数重载</p>
<h2 id="显示禁用默认函数"><a href="#显示禁用默认函数" class="headerlink" title="显示禁用默认函数"></a>显示禁用默认函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Magic </div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Magic() = default; // 显式声明使用编译器生成的构造</div><div class="line">    Magic&amp; operator=(const Magic&amp;) = delete; // 显式声明拒绝编译器生成构造</div><div class="line">    Magic(int magic_number);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum class new_enum:unsigned int</div><div class="line">&#123;</div><div class="line">    ETYPE1,</div><div class="line">    ETYPE2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要是这么定义的枚举不会像以前那样被隐式转换了。</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p><a href=""></a>{}定义。。。<br>[]是捕获列表，[var1, var2]捕获变量，[&amp;]按引用捕获，[=]按值捕获</p>
<h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p>我的理解就是一个函数对象</p>
<h2 id="std-bind-std-placeholder"><a href="#std-bind-std-placeholder" class="headerlink" title="std::bind / std:placeholder"></a>std::bind / std:placeholder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int fun(int a, int b, int c)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">auto fun = std::bind(fun, std::placeholders::_1, 1, 2)</div><div class="line"></div><div class="line">fun(999); //相当于 fun(999, 1, 2);</div></pre></td></tr></table></figure>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>###左值(lvalue, left value)<br>顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p>
<p>###右值(rvalue, right value)<br>赋值符号右边的值，是指表达式结束后就不再存在的临时对象。</p>
<p>###纯右值(prvalue, pure rvalue)<br>纯粹的右值，要么是纯粹的字面量，例如 10 ,true ；要么是求值结果相当于字面量或匿名临时对象，例如 1+2 。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。</p>
<p>###将亡值(xvalue, expiring value)<br>是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中，纯右值和右值是统一个概念），也就是即将被销毁、却能够被移动的值。</p>
<p>右值引用的申明 T &amp;&amp;<br>std::move 这个方法将左值参数无条件的转换为右值</p>
<p>移动语义<br>之前的类拷贝是创一个新的然后塞过去。就导致一个循环会创很多临时变量<br>用移动语义会拿到将亡值，然后直接拷贝内存。就不用创新的了。</p>
<p>模板函数中使用 T&amp;&amp; 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。</p>
<h2 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h2><p>std::array 是封装固定大小数组的容器。<br>std::array<int, 3=""> a = {1,2,3};<br>std::array 保存在栈内存,std::vector保存在堆内存。</int,></p>
<h2 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h2><p>和std::list差不多。不过是单向的</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>std::unordered_map / std::unordered_multimap 和std::unordered_set / std::unordered_multiset 。<br>内部是Hash实现的。复杂度是O(constant)</p>
<h2 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h2><p>类模板 std::tuple 是固定大小的异类值汇集</p>
<ol>
<li>std::make_tuple : 构造元组</li>
<li>std::get : 获得元组某个位置的值</li>
<li>std::tie : 元组拆包</li>
</ol>
<p>RAII全称为Resource Acquisition Is Initialization 资源获取就是初始化</p>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>只能指针，，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示的调用 delete ，当引用计数变为零的时候就会将对象自动删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::shared_ptr pointer = std::make_shared&lt;int&gt;(10);</div><div class="line">std::shared_ptr&lt;int&gt; pointer2 = pointer; //计数+1</div></pre></td></tr></table></figure></p>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>独占的智能指针，它禁止其他智能指针与其共享同一个对象。可以使用std::move 将其转移给其他的 unique_ptr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::unique_ptr&lt;int&gt; pointer = std::make_unique&lt;int&gt;(10); </div><div class="line">std::unique_ptr&lt;int&gt; pointer2 = pointer;  //非法</div></pre></td></tr></table></figure></p>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p> std::weak_ptr 用来表达临时所有权的概念：当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用 std::weak_ptr 来跟踪该对象。需要获得临时所有权时，则将其转换为 std::shared_ptr，此时如果原来的 std::shared_ptr 被销毁，则该对象的生命期将被延长至这个临时的 std::shared_ptr 同样被销毁为止。</p>
<h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p>用于创建一个执行的线程实例</p>
<h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>互斥量，通过其成员函数 lock() 可以仅此能上锁， unlock() 可以进行解锁。配合std::lock_gurad 使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void some_operation(const std::string &amp;message)</div><div class="line"> &#123;</div><div class="line">    static std::mutex mutex;</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex);</div><div class="line">    // ...操作</div><div class="line">    // 当离开这个作用域的时候，互斥锁会被析构，同时unlock互斥锁</div><div class="line">    // 因此这个函数内部的可以认为是临界区</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>std::unique_lock 独占权管理mutex</p>
<p>std::future, std::packaged_task 异步操纵结果</p>
<p>std::condition_variable 条件竞争</p>
<p><a href="https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details" target="_blank" rel="external">其实也没怎么用过，详细要看这个</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/07/20/dx11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/20/dx11/" itemprop="url">dx11学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T10:43:37+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>最近老是查一些显存的内存泄漏问题，因为ue4在pc上的rhi基本上都是dx实现，有很多看的不是很懂的地方，感觉需要学习一下这玩意。</p>
<h1 id="Direct3d"><a href="#Direct3d" class="headerlink" title="Direct3d"></a>Direct3d</h1><p>官网的介绍是</p>
<blockquote>
<p>Direct3D is a low-level API that you can use to draw triangles, lines, or points per frame, or to start highly parallel operations on the GPU.</p>
</blockquote>
<p>其实就是一组操作图像的api。。</p>
<h1 id="DXGI"><a href="#DXGI" class="headerlink" title="DXGI"></a>DXGI</h1><p>Microsoft DirectX Graphics Infrastructure (DXGI)，我的理解就是一个位于Direct3d和硬件的中间层，查了一下说是，因为dx不停的升级，每个版本有很多能共享的代码，放到这里面来管理了。</p>
<h1 id="The-Swap-Chain"><a href="#The-Swap-Chain" class="headerlink" title="The Swap Chain"></a>The Swap Chain</h1><p>因为显示器刷新没有gpu快，所以会有一个交换链的机制用于渲染，就是两块缓存区域，当前显示的时候，可能后台下一帧已经准备好了。</p>
<h1 id="ID3D11Device"><a href="#ID3D11Device" class="headerlink" title="ID3D11Device"></a>ID3D11Device</h1><p>In Direct3D, a device is an object that is intended to be a virtual representation of your video adapter. 应该是显卡的抽象，用来创建资源。</p>
<h1 id="ID3D11DeviceContext"><a href="#ID3D11DeviceContext" class="headerlink" title="ID3D11DeviceContext"></a>ID3D11DeviceContext</h1><p>A device context is similar to a device, but it is responsible for managing the GPU and the rendering pipeline (the device mostly handles video memory). This object is used to render graphics and to determine how they will be rendered.<br>主要是用来管理gpu渲染流程。</p>
<h1 id="IDXGISwapChain"><a href="#IDXGISwapChain" class="headerlink" title="IDXGISwapChain"></a>IDXGISwapChain</h1><p>就是刚才说的交换链的抽象，用来交换前后台的缓存的buffer</p>
<h1 id="DXGI-SWAP-CHAIN-DESC"><a href="#DXGI-SWAP-CHAIN-DESC" class="headerlink" title="DXGI_SWAP_CHAIN_DESC"></a>DXGI_SWAP_CHAIN_DESC</h1><p>交换链的描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef struct DXGI_SWAP_CHAIN_DESC</div><div class="line">    &#123;</div><div class="line">    DXGI_MODE_DESC BufferDesc;</div><div class="line">    DXGI_SAMPLE_DESC SampleDesc; //采样</div><div class="line">    DXGI_USAGE BufferUsage;</div><div class="line">    UINT BufferCount;  //后台缓冲区数量</div><div class="line">    HWND OutputWindow;  </div><div class="line">    BOOL Windowed;</div><div class="line">    DXGI_SWAP_EFFECT SwapEffect;</div><div class="line">    UINT Flags;</div><div class="line">    &#125; 	DXGI_SWAP_CHAIN_DESC;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/26/insideC-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/insideC-3/" itemprop="url">InsideC++笔记 Function语义学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T15:32:05+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Function-语义学"><a href="#Function-语义学" class="headerlink" title="Function 语义学"></a>Function 语义学</h1><h2 id="非静态成员函数-NonStatic-Member-Functions"><a href="#非静态成员函数-NonStatic-Member-Functions" class="headerlink" title="非静态成员函数  NonStatic Member Functions"></a>非静态成员函数  NonStatic Member Functions</h2><p>调用非静态成员函数的时候没有额外的开销，因为编译器会把非静态成员函数转换为一个局部函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//非成员函数</div><div class="line">float magnitude3d(const Point3d *_this)&#123;...&#125;</div><div class="line">//成员函数</div><div class="line">float Point3d::magnitude3d()const&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>编译器对非静态成员函数的操作:<br>1.改写函数签名，把this指针插入到函数中</p>
<blockquote>
<p>float Point3d::magnitude3d(Point3d *const this)</p>
</blockquote>
<p>2.把所有的非静态成员数据改成用this指针调用<br>3.把成员函数的名字改成一个独一无二的名称</p>
<blockquote>
<p>extern magnitude_7Point3dFv(regiser Point3d *const this);</p>
</blockquote>
<p>4.把所有函数调用的地方替换了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj.magnitude(); // magnitude_7Point3dFv(&amp;obj);</div><div class="line">ptr-&gt;magnitude(); // magnitude_7Point3dFv(ptr);</div></pre></td></tr></table></figure></p>
<h2 id="虚函数-Virtual-Member-Functions"><a href="#虚函数-Virtual-Member-Functions" class="headerlink" title="虚函数 Virtual Member Functions"></a>虚函数 Virtual Member Functions</h2><p>如果normalize声明为虚函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;normalize(); // (*ptr-&gt;vptr[1](ptr);</div><div class="line">obj.normalize(); // (* obj.vptr[1])(&amp;obj);</div></pre></td></tr></table></figure></p>
<p>因为obj的调用方式说明他不支持多态，所以这个调用会想非静态成员函数一样转换为</p>
<blockquote>
<p>normalize_7Point3dFv(&amp;obj);</p>
</blockquote>
<h2 id="静态成员函数Static-member-function"><a href="#静态成员函数Static-member-function" class="headerlink" title="静态成员函数Static  member function"></a>静态成员函数Static  member function</h2><p>因为这货没有this指针，所以基本上跟非成员函数差不多。</p>
<h1 id="Virtual-Member-Functions-虚函数"><a href="#Virtual-Member-Functions-虚函数" class="headerlink" title="Virtual Member Functions 虚函数"></a>Virtual Member Functions 虚函数</h1><h2 id="单继承下的虚函数"><a href="#单继承下的虚函数" class="headerlink" title="单继承下的虚函数"></a>单继承下的虚函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prt-&gt;z();</div></pre></td></tr></table></figure>
<p>如果z是一个虚函数，那么执行期是如何正确调用z的呢？</p>
<h3 id="虚函数实现的机制"><a href="#虚函数实现的机制" class="headerlink" title="虚函数实现的机制"></a>虚函数实现的机制</h3><p>首先多态对象会增加两个成员</p>
<ol>
<li>一个字符串或数字表示clas的类型，</li>
<li>一个指针，指针指向一个表格，表格是所有虚函数的执行期地址。<br>为每个虚函数分配一个索引，用来查找在表格中的位置。</li>
<li>继承类继承派生类的所有虚函数表，</li>
<li>如果继承类里面有个override了虚函数的，就要在对应索引位置用重写的函数地址覆盖。</li>
<li>派生类可以加入新的虚函数</li>
</ol>
<h2 id="多重继承下的虚函数"><a href="#多重继承下的虚函数" class="headerlink" title="多重继承下的虚函数"></a>多重继承下的虚函数</h2><p>多重继承结构下，基本上继承几个就有几个虚函数表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Base1</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Base1();</div><div class="line">	virtual ~Base1();</div><div class="line">	virtual void func1();</div><div class="line">	virtual void Base1 *clone() const;</div><div class="line">protected:</div><div class="line">	float data_base1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Base2</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Base2();</div><div class="line">	virtual ~Base2();</div><div class="line">	virtual void func2();</div><div class="line">	virtual void Base2 *clone() const;</div><div class="line">protected:</div><div class="line">	float data_base2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">class Derived: public Base1, public Base2</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Derived();</div><div class="line">	virtual ~Derived();</div><div class="line">	virtual void Derived *clone() const;</div><div class="line">protected:</div><div class="line">	float data_Derived;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上面的继承结构Derived类，继承了Base1,Base2<br>Base1的虚函数表结构：</p>
<blockquote>
<p>[0] Base1::~Base1()<br>[1] Base1::func1()<br>[2] Base1::clone()</p>
</blockquote>
<p>Base2的虚函数表结构：</p>
<blockquote>
<p>[0] Base2::~Base2();<br>[1] Base2::func2();<br>[2] Base2::clone();</p>
</blockquote>
<p>Derived会产生两个虚函数表:<br>_vptr_Base1的结构</p>
<blockquote>
<p>[0] Derived::~Derived()<br>[1] Base1::func1()<br>[2] Derived::clone()<br>[3] Base2::func2()</p>
</blockquote>
<p>_vptr_Base2的结构</p>
<blockquote>
<p>[0] Derived::~Derived()<br>[1] Base2::func2()<br>[2] Derived::clone()</p>
</blockquote>
<h2 id="虚拟继承下的虚函数"><a href="#虚拟继承下的虚函数" class="headerlink" title="虚拟继承下的虚函数"></a>虚拟继承下的虚函数</h2><p>当菱形继承结构时,用虚继承，是为了避免重复拷贝，所以会保存一份副本。<br>如A派生出B、C 又D虚继承与B,C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">class B:public A&#123;&#125;</div><div class="line">class C:public A&#123;&#125;</div><div class="line">class D:public virtual B, public virtual C&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候D的结构会有B的虚函数表，C的虚函数表，还有共享的A的虚函数表<br>要注意的是多重继承，且虚继承的时候，最上次的基类中最好不要定义成员数据。</p>
<h2 id="内联函数-inline-function"><a href="#内联函数-inline-function" class="headerlink" title="内联函数 inline function"></a>内联函数 inline function</h2><p>设置inline只是一个请求，实际是否为内联函数是由编译器决定的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">inline int bar()</div><div class="line">&#123;</div><div class="line">	int minval;</div><div class="line">	int val1 = 1024;</div><div class="line">	int val2 = 2048;</div><div class="line"></div><div class="line">	minval = min(val1, val2);     // 1</div><div class="line">	minval = min(1024, 2048); 	  // 2</div><div class="line">	minval = min(foo(), bar()+1); //3 </div><div class="line">	return minval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>情况1 参数直接代换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minval = val1 &lt; val2 ? val2 : val2;</div></pre></td></tr></table></figure></p>
<p>情况2 直接使用常量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minval = 1024；</div></pre></td></tr></table></figure></p>
<p>情况3 为避免重复求值会导入一个临时对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int t1,t2;</div><div class="line">minval = (t1=foo()), (t2=bar()+1), t1&lt;t2?t1:t2;</div></pre></td></tr></table></figure></p>
<p>如果在inline定义里面加入一个局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">inline int min(int i, int j)</div><div class="line">&#123;</div><div class="line">	int local_val;</div><div class="line">	int mainval;</div><div class="line">	...</div><div class="line">	minval = min(vall1, val2); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般而言，inline函数里面的每个局部变量都会放在函数的一个封闭区域内，且被设成一个独一无二的名字。<br>所以要注意的是滥用含局部变量，且有副作用参数加入临时对象的情况，会导致程序的扩张。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/19/insideC-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/19/insideC-2/" itemprop="url">InsideC++笔记 Data语义学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T11:01:38+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="虚基类继承时的内存分布对象"><a href="#虚基类继承时的内存分布对象" class="headerlink" title="虚基类继承时的内存分布对象"></a>虚基类继承时的内存分布对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class X&#123;&#125;;</div><div class="line">class Y:public virtual X&#123;&#125;;</div><div class="line">class Z:public virtual X&#123;&#125;;</div><div class="line">class A:public Y, public Z&#123;&#125;;</div></pre></td></tr></table></figure>
<p>使用sizeof之后<br>size X = 1<br>size Y = 8(vc++下等于4)<br>size Z = 8(vc++下等于4)<br>size A = 12(vc++下等于8)</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>sizeof(X)时，虽然什么都没有，但是编译器会安插一个char类型保证对象的内存地址独一无二。所以sizeof(x)==1</li>
<li>对于类Y和Z，因为虚继承了X,编译器就会自己生成一个指针指向虚基类或者指向一个表格，表格里面存放着虚基类的地址或者偏移量。所以此时的Y,Z的大小就是指针的大小加上X的大小就等于5个bytes。然后在被内存对齐就是8bytes了<br><em>为什么vc++下面，Y,Z大小是4？</em><br>因为X是空的虚基类，在一些编译器下面就被优化了。一个空的虚基类会被看成派生类的开头部分,所以就节省了那个1个bytes，所以大小为4bytes</li>
<li>对于A的大小，需要注意的是无论同一个虚基类被继承了多少次，只会有一个实体。所以A的大小就是1+8等于9bytes然后再对齐一下就变成了12bytes。同理vc++编译器下是8个bytes</li>
</ol>
<h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>编译器会把一个以上的access section(public, private, protect)连锁在一起，所以定义多个sections不消耗额外的性能。access level中的member的排列次序必须和声明的次序相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Point3d</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual ~Point3d();</div><div class="line">private:</div><div class="line">	static 	Point3d origin;</div><div class="line">	float x, y, z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>取某个坐标成员的地址 &amp;Point3d::z，等价于z坐标在class Point3d中的偏移量offset。</p>
<h3 id="编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？"><a href="#编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？" class="headerlink" title="编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？"></a>编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？</h3><p>float Point3d::<em>p1 = 0;<br>float Point3d::</em>p2  = &amp;Point3d::x;<br>为了让编译器能区别上面两个指针，每个member的offset都会加1，这时候如果两个值相等，那说明他们肯定指向同一个数据成员。</p>
<h3 id="两种存取方式"><a href="#两种存取方式" class="headerlink" title="两种存取方式"></a>两种存取方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Point3d Origin, *pt = &amp;origin;</div><div class="line">origin.X = 0.0;</div><div class="line">pt-&gt;x = 0.0;</div></pre></td></tr></table></figure>
<p>所以对于这两种存取方式的效率问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">origin.x = 0.0F;        // 等价于 *(&amp;origin + (&amp;Point3d::x - 1)) = 0.0;</div><div class="line">pt-&gt;x = 0.0F;           // 等价于 *(pt + (&amp;Point3d::x - 1)) = 0.0;</div></pre></td></tr></table></figure></p>
<p>最大的问题在于Point3d的不确定性，如果他是一个派生类,而X是继承而来的。所以编译器是不知道Pt中X的offset,但是Origin则肯定是Point3d类型了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/15/InsideC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/InsideC/" itemprop="url">InsideC++笔记 构造函数篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-15T18:44:05+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h1><h2 id="Default-Constructor"><a href="#Default-Constructor" class="headerlink" title="Default Constructor"></a>Default Constructor</h2><h3 id="编译器生成默认构造函数"><a href="#编译器生成默认构造函数" class="headerlink" title="编译器生成默认构造函数"></a>编译器生成默认构造函数</h3><ul>
<li>类里面有一个member object,且该对象有一个默认构造函数，如果有一个以上的成员对象，会按成员对象声明的顺序，依次调用每个构造函数的。</li>
<li>类的基类有默认构造函数</li>
<li>类或基类的成员函数有虚函数</li>
<li>类的基类有Virtual Base Calss</li>
</ul>
<p>所以说并不是所有的类没有定义默认构造函数，编译器就会自己生成一个！！</p>
<h2 id="Copy-Constructor"><a href="#Copy-Constructor" class="headerlink" title="Copy Constructor"></a>Copy Constructor</h2><h3 id="三个调用的情况"><a href="#三个调用的情况" class="headerlink" title="三个调用的情况"></a>三个调用的情况</h3><p>作为初始化赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class X &#123;...&#125;;</div><div class="line">X x;</div><div class="line">X xx = x;</div></pre></td></tr></table></figure></p>
<p>作为函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern void foo(X x);</div><div class="line">void bar</div><div class="line">&#123;</div><div class="line"> X xx;</div><div class="line"> foo(xx);	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作为返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">X func()</div><div class="line">&#123;</div><div class="line"> X xx;</div><div class="line"> ...</div><div class="line"> return xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h3><p>当没有显示定义拷贝构造函数的时候，用一个相同的对象作为另一个对象的初始值，就会以递归的方式，把成员数据一个一个赋值上去。碰到成员是class，就进入这个class再一个一个拷贝class的成员数据。</p>
<h3 id="BitWise-Copy-Semantics-位逐次拷贝"><a href="#BitWise-Copy-Semantics-位逐次拷贝" class="headerlink" title="BitWise Copy Semantics 位逐次拷贝"></a>BitWise Copy Semantics 位逐次拷贝</h3><p>上述的Default Memberwise Initialization只在符合BitWise Copy Semantics的情况下才会实行。<br>不符合BitWise Copy Semantics 的情况：</p>
<ul>
<li>class的数据成员里面有定义了Copy Constructor的object</li>
<li>class的基类里面有定义Copy Constructor</li>
<li>class定义了虚函数</li>
<li>class有一个或多个虚基类</li>
</ul>
<p><strong>为什么不能有虚函数？</strong><br>因为可能会拷贝vptr，而导致一些错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">virtual void func()</div><div class="line">&#125;;</div><div class="line">class B:A</div><div class="line">&#123;</div><div class="line">virtual void func();</div><div class="line">&#125;;</div><div class="line">B b1;</div><div class="line">B b2 =b1;</div><div class="line">A a = b1; </div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>因为用b1初始化a的过程，会产生截断，如果采用位逐次拷贝的话，会把B的虚函数表拷完全拷给A，这时候要是A调用虚函数，可能会发生错误。</p>
<p><strong>为什么不能有虚基类？</strong><br>我的理解是编译器无法知道要开拷贝的这个对象是该对象本身还是一个指向基类的对象。</p>
<h2 id="Named-Return-Value优化"><a href="#Named-Return-Value优化" class="headerlink" title="Named Return Value优化"></a>Named Return Value优化</h2><p>对于代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void function()</div><div class="line">&#123;</div><div class="line">	X x1(x0);</div><div class="line">	X x2 = x0;</div><div class="line">	x x3 =X(x0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会被程序转换成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void function()</div><div class="line">&#123;</div><div class="line">	X x1;</div><div class="line">	X x2;</div><div class="line">	X x3;</div><div class="line"></div><div class="line">	//X::X(const X&amp;xx)</div><div class="line">	x1.X::X(x0);</div><div class="line">	x2.X::X(x0);</div><div class="line">	x3.X::X(x0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">X func()</div><div class="line">&#123;</div><div class="line"> X xx;</div><div class="line"> ...</div><div class="line"> return xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会变成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void func(X&amp; __result)</div><div class="line">&#123;</div><div class="line">	X xx;</div><div class="line">	xx.X::X();</div><div class="line">	...</div><div class="line">	__result.X::X(xx);</div><div class="line">	return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过对于函数和对象复杂的时候这种优化会坑爹。。。</p>
<h2 id="成员初始化列表-Member-Initialization-List"><a href="#成员初始化列表-Member-Initialization-List" class="headerlink" title="成员初始化列表 Member Initialization List"></a>成员初始化列表 Member Initialization List</h2><p>使用情况</p>
<ul>
<li>当初始化一个reference member时</li>
<li>当初始化一个const member时</li>
<li>当调用一个base class 的constructor,而它拥有一组参数</li>
<li>当调用一个member class的constructor，而它拥有一组参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">	String Name;</div><div class="line">	int cnt;</div><div class="line">public:</div><div class="line">	A()&#123;</div><div class="line">		Name = 0;</div><div class="line">		cnt  = 0;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这种写法本身是没毛病，但是Name是个对象，上面的代码就会扩张成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A::A()</div><div class="line">&#123;</div><div class="line">  Name.String::String();</div><div class="line">  String temp = String(0);</div><div class="line">  Name.String::operate=(temp);</div><div class="line">  temp.String::~String();</div><div class="line"></div><div class="line">  cnt = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以更好的写法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A::A</div><div class="line">:Name(0)</div><div class="line">&#123;</div><div class="line">	cnt = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那问题来了，所有的成员都用列表初始化么。<br>对于以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	int j;</div><div class="line">public:</div><div class="line">  A(int val)</div><div class="line">  :j(val)</div><div class="line">  ,i(j)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为初始化列表会按定义的属性初始化，所以先是i被j赋值，然后j才被val赋值，这时候i就会是个未定义的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A::A(int val)</div><div class="line"> : j(val)</div><div class="line">&#123;</div><div class="line"> 	i = j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这种代码i还是未定义的，因为初始化列表总是在大括号执行完之后才执行的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/14/设计稿(第一版)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/14/设计稿(第一版)/" itemprop="url">设计稿(第一版)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-14T17:24:51+08:00">
                2017-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/游戏/" itemprop="url" rel="index">
                    <span itemprop="name">游戏</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>一直想做个自己觉得有意思的游戏，但是因为太懒，一直没有行动起来。最近的项目用的是Unreal引擎，但是接触引擎的大部分都是场景部分的模块，对角色动画，AI完全不了解，希望这个demo能学习一下这方面的知识，也能圆了自己一个小小的愿望。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>构思中的游戏是一个魔法世界的背景，主角在一个魔法塔里面。开始是一个新手学徒，然后通过完成老师的各种任务，完成魔法塔周围的地下城，成为牛逼大法师的狗血故事。</p>
<h1 id="培养"><a href="#培养" class="headerlink" title="培养"></a>培养</h1><p>希望能做成一个养成游戏，披着魔法外壳的牧场物语，通过培养角色的属性，体验慢慢成长的乐趣。战斗可能只是去收集材料，大部分时间是在魔塔里面的。 </p>
<h1 id="核心系统"><a href="#核心系统" class="headerlink" title="核心系统"></a>核心系统</h1><h2 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h2><ul>
<li>时间类型 时间流逝会对世界造成影响。</li>
<li>角色属性 待设计</li>
<li>魔法类型 待设计</li>
<li>战斗系统 希望能做成上古卷轴，巫师那种战斗模式吧。</li>
</ul>
<h2 id="次要"><a href="#次要" class="headerlink" title="次要"></a>次要</h2><ul>
<li>药剂学 需要有一个种菜系统，和一个炼药系统。</li>
<li>炼金学 需要一个抓怪物的系统，和培养怪物的系统。</li>
</ul>
<h1 id="地下城"><a href="#地下城" class="headerlink" title="地下城"></a>地下城</h1><p>地下城的可能有怪物，也可能是跳机关陷阱，可也能是解密。是所有材料，宝物产出的地方。</p>
<h1 id="多人联机"><a href="#多人联机" class="headerlink" title="多人联机"></a>多人联机</h1><p>待定</p>
<p>…………………………………………………………………………………….<br>2017-7-4 总结<br>花了两个周末，完成了人物的基本逻辑，动作行为状态机，行走跑跳攻击，连击。主要的问题在于动作连贯表现不是很好。不过对UE4动画系统那一套 基本上搞明白了怎么用。<br>然后又研究了ai系统，实现了一个简单的怪物巡逻，然后发现主角了会自己过来攻击的逻辑。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sylar" />
          <p class="site-author-name" itemprop="name">Sylar</p>
           
              <p class="site-description motion-element" itemprop="description">You have a dream, you gotta to protect it.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sylar</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
