<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="You have a dream, you gotta to protect it.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sylar&#39;s Notes">
<meta property="og:url" content="http://www.hhhhyf.com/index.html">
<meta property="og:site_name" content="Sylar&#39;s Notes">
<meta property="og:description" content="You have a dream, you gotta to protect it.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sylar&#39;s Notes">
<meta name="twitter:description" content="You have a dream, you gotta to protect it.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.hhhhyf.com/"/>





  <title>Sylar's Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sylar's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/11/14/cpp-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/cpp-concurrency/" itemprop="url">《C++ Concurrency in Action》笔记(线程管理，线程间共享数据)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T10:32:45+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h1><h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void function()</div><div class="line"></div><div class="line">std::thread MyThread(function);  </div><div class="line">std::thread MyThread((function())); </div><div class="line">std::thread MyThread&#123;function()&#125;;</div><div class="line">std::thread MyThread([]()&#123;function();&#125;);</div><div class="line"></div><div class="line">MyThread.detach(); //不等待线程结束</div><div class="line">MyThread.join(); //等待线程结束</div></pre></td></tr></table></figure>
<p>可以detach之后在join回来，join之后detach出去。</p>
<h2 id="向线程函数传递参数"><a href="#向线程函数传递参数" class="headerlink" title="向线程函数传递参数"></a>向线程函数传递参数</h2><ul>
<li>线程的构造函数无视函数期待的参数类型,<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void Print(const string&amp; str);</div><div class="line">string str = &quot;1111&quot;;</div><div class="line">std::thread TestThread(Print, str); //输出111</div><div class="line">std::thread TestThread(Print, std::ref(str)); //输出222</div><div class="line">str = &quot;222&quot;;</div><div class="line">TestThread.join();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>std::ref 将参数转换成引用的形式</p>
<ul>
<li><p>使用绑定传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Test</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	void Print(int x) &#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	Test MyTest;</div><div class="line">	int x = 11;</div><div class="line">	std::thread MyThread(&amp;Test::Print, &amp;MyTest, x);</div><div class="line">	MyThread.join();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用std::move移动传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void ProcessTest(std::unique_ptr&lt;Test&gt; UniquePointer)</div><div class="line">&#123;</div><div class="line">	UniquePointer-&gt;Print(123);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	std::unique_ptr&lt;Test&gt; TestPointer(new Test);</div><div class="line">	std::thread MyThread(ProcessTest, std::move(TestPointer));</div><div class="line">	MyThread.join();</div><div class="line">	system(&quot;pause&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="转移线程所有权"><a href="#转移线程所有权" class="headerlink" title="转移线程所有权"></a>转移线程所有权</h2><p>thread是可以move不可以copy的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void fun1()</div><div class="line">void fun2()</div><div class="line">std::thread t1(fun1); //t1 拥有执行函数fun1</div><div class="line">std::thread t2 = std::move(t1); //t2拥有t1的使用权，t1现在没有执行函数</div><div class="line">t1 = std::thread(fun2); //t1拥有执行函数fun2</div><div class="line"></div><div class="line">std::thread t3; </div><div class="line">t3 = std::move(t2); //t3现在拥有t2的使用权，t2现在没有执行函数。</div><div class="line">t1 = std::move(t3); //t1之前拥有执行函数fun2,不能被赋值，崩溃</div></pre></td></tr></table></figure></p>
<p>不能通过赋一个新值给 std::thread 对象的方式来”丢弃”一个线程,。std::move移动就是转移控制权，原先的资源被销毁。</p>
<h2 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">std::thread MyTread(func);</div><div class="line">std::thread::id = MyTread.get_id();</div><div class="line">std::thread::id = std::this_thread::get_id();</div></pre></td></tr></table></figure>
<hr>
<h1 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h1><h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>多个线程并发的修改同一个数据块，会造成未定义的行为。</p>
<h2 id="使用互斥量保护共享数据"><a href="#使用互斥量保护共享数据" class="headerlink" title="使用互斥量保护共享数据"></a>使用互斥量保护共享数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::mutex MyMutex;</div><div class="line">std::lock_guard&lt;std::mutex&gt; guard(MyMutex);</div></pre></td></tr></table></figure>
<p>例子：线程安全的stack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">class empty_stack_exception:std::exception</div><div class="line">&#123;</div><div class="line">	const char* what() const throw()</div><div class="line">	&#123;</div><div class="line">		return &quot;empty stack!&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">class ThreadSafe_Stack</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">	std::stack&lt;T&gt; data;</div><div class="line">	mutable std::mutex m;</div><div class="line"></div><div class="line">public:</div><div class="line">	ThreadSafe_Stack()</div><div class="line">		:data(std::stack&lt;T&gt;())&#123;&#125;</div><div class="line"></div><div class="line">	ThreadSafe_Stack(const ThreadSafe_Stack&amp; Other)</div><div class="line">	&#123;</div><div class="line">		std::lock_guard&lt;std::mutex&gt; guard(m);</div><div class="line">		data = Other.data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ThreadSafe_Stack&amp; operator=(const ThreadSafe_Stack &amp;) = delete;</div><div class="line"></div><div class="line">	void Push(T new_value)</div><div class="line">	&#123;</div><div class="line">		std::lock_guard&lt;std::mutex&gt; guard(m);</div><div class="line">		data.push(new_value);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	std::shared_ptr&lt;T&gt; Pop()</div><div class="line">	&#123;</div><div class="line">		std::lock_guard&lt;std::mutex&gt; guard(m);</div><div class="line">		if (data.empty())</div><div class="line">			throw empty_stack_exception();</div><div class="line">		std::shared_ptr&lt;T&gt; const Res(std::make_shared&lt;T&gt;(data.pop()));</div><div class="line">		data.pop();</div><div class="line">		return Res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	void Pop(T&amp; Value)</div><div class="line">	&#123;</div><div class="line">		std::lock_guard&lt;std::mutex&gt; guard(m);</div><div class="line">		if (data.empty())</div><div class="line">		&#123;</div><div class="line">			throw empty_stack_exception();</div><div class="line">		&#125;</div><div class="line">		Value = data.top();</div><div class="line">		data.pop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	bool empty()const</div><div class="line">	&#123;</div><div class="line">		std::lock_guard&lt;std::mutex&gt; lock(m);</div><div class="line">		return data.empty();</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或两个以上的互斥量来锁定了一个操作。造成互相等待另一个线程解锁。<br>std::lock 可以一次性锁住多个互斥量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">struct bank_account &#123;</div><div class="line">    explicit bank_account(int balance) : balance(balance) &#123;&#125;</div><div class="line">    int balance;</div><div class="line">    std::mutex m;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">void transfer(bank_account &amp;from, bank_account &amp;to, int amount)</div><div class="line">&#123;</div><div class="line">    // lock both mutexes without deadlock</div><div class="line">    std::lock(from.m, to.m);</div><div class="line">    // make sure both already-locked mutexes are unlocked at the end of scope</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock1(from.m, std::adopt_lock);</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock2(to.m, std::adopt_lock);</div><div class="line"> </div><div class="line">// equivalent approach:</div><div class="line">//    std::unique_lock&lt;std::mutex&gt; lock1(from.m, std::defer_lock);</div><div class="line">//    std::unique_lock&lt;std::mutex&gt; lock2(to.m, std::defer_lock);</div><div class="line">//    std::lock(lock1, lock2);</div><div class="line"> </div><div class="line">    from.balance -= amount;</div><div class="line">    to.balance += amount;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    bank_account my_account(100);</div><div class="line">    bank_account your_account(50);</div><div class="line"> </div><div class="line">    std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);</div><div class="line">    std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);</div><div class="line"> </div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>std::defer_lock, std::try_to_lock, std::adopt_lock<br>defer_lock_t    do not acquire ownership of the mutex<br>try_to_lock_t    try to acquire ownership of the mutex without blocking<br>adopt_lock_t    assume the calling thread already has ownership of the mutex</p>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul>
<li>避免嵌套锁 一个线程已获得一个锁时，再别去获取第二个。</li>
<li>避免在持有锁时调用用户提供的代码 </li>
<li>使用固定顺序获取锁</li>
</ul>
<p>std::lock_guard ，是一个参数化的互斥量模板类，并且它提供很多RAII类型锁用来管理 std::lock_guard 类型</p>
<h2 id="std-unique-lock——灵活的锁"><a href="#std-unique-lock——灵活的锁" class="headerlink" title="std::unique_lock——灵活的锁"></a>std::unique_lock——灵活的锁</h2><p>支持lock(), try_lock()和unlock()成员函数，所以能将 std::unique_lock 对象传递到 std::lock()std::unique_lock 对象的体积通常要比 std::lock_guard 对象大，当使用 std::unique_lock 替代 std::lock_guard ，因为会对标志进行适当的更新或检查，就会做些轻微的性能惩罚。当 std::lock_guard 已经能够满足你的需求，那么还是建议你继续使用它。当需要更加灵活的锁时，最好选择 std::unique_lock</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>锁的粒度是用来描述通过一个锁保护着的数据量大小。一个细粒度锁能够保护较小的数据量，一个粗粒度锁能够保护较多的数据量。</p>
<h2 id="保护共享数据的替代设施"><a href="#保护共享数据的替代设施" class="headerlink" title="保护共享数据的替代设施"></a>保护共享数据的替代设施</h2><p>双重检查锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void undefined_behaviour_with_double_checked_locking()</div><div class="line">&#123;</div><div class="line">    if(!resource_ptr) // 1</div><div class="line">    &#123;</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(resource_mutex);</div><div class="line">        if(!resource_ptr) // 2</div><div class="line">        &#123;</div><div class="line">            resource_ptr.reset(new some_resource); // 3</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    resource_ptr-&gt;do_something(); // 4</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1的读取操作与3个写入操作没有同步，会产生条件竞争。会导致未定义行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</div><div class="line">std::once_flag resource_flag; // 1</div><div class="line">void init_resource()</div><div class="line">&#123;</div><div class="line">    resource_ptr.reset(new some_resource);</div><div class="line">&#125;</div><div class="line">void foo()</div><div class="line">&#123;</div><div class="line">    std::call_once(resource_flag,init_resource); // 可以完整的进行一次初始化</div><div class="line">    resource_ptr-&gt;do_something();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 std::call_once 的结束时，就能安全的知道指针已经被其他的线程初始化了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/11/08/c-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/c-11/" itemprop="url">c++11/14学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T15:39:43+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.gitbook.com/book/changkun/cpp1x-tutorial/details" target="_blank" rel="external">学习资料</a></p>
<h1 id="c-的特性"><a href="#c-的特性" class="headerlink" title="c++的特性"></a>c++的特性</h1><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>之前的NULL，有时候编译器会为((void*)0),有的会定义为0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char *Ch = NULL;</div><div class="line">void foo(char *);</div><div class="line">void foo(int);</div></pre></td></tr></table></figure></p>
<p>这种情况。因为NULL被定义0了，调用foo(CH)重载就调用foo(int)了，就会产生未知的错误。</p>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>这玩意就是显示声明函数或者构造函数为常数，在编译的时候就告诉编译器，函数xxx是一个常量。感觉用在递归函数啊什么的，提高性能的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">constexpr int fibonacci(const int n) &#123;</div><div class="line">if(n == 1) return 1;</div><div class="line">if(n == 2) return 1;</div><div class="line">return fibonacci(n-1)+fibonacci(n-2);</div></pre></td></tr></table></figure></p>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>自动推导类型，我一般都用在那种模板里面很长的变量的定义，不能用在函数参数推导，数组类型推导。</p>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype(表达式) 和auto配合使用，推导出表达式的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto x = 1;</div><div class="line">auto y = 2;</div><div class="line">decltype(x+y) z;</div></pre></td></tr></table></figure></p>
<p>在模板中使用，得到返回类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//c11</div><div class="line">template&lt;typename T, typename U&gt;</div><div class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</div><div class="line">return x+y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//c14后可以直接</div><div class="line">template&lt;typename T, typename U&gt;</div><div class="line">auto add(T x, U y) &#123;</div><div class="line">return x+y</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(auto &amp;i: array)</div><div class="line">&#123;</div><div class="line">    std:count &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>之前只有那些结构体啊，数组可以用{}进行初始化。但是类就只能通过构造函数。<br>以前初始化一个容器需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int a[] = &#123;0, 1, 2, 3&#125;;</div><div class="line">std:vector&lt;int&gt; vec(a, a+sizeof(a));</div><div class="line">//或者</div><div class="line">vec.push_back(0);</div><div class="line">vec.push_back(1);</div><div class="line">vec.push_back(2);</div><div class="line">vec.push_back(3);</div><div class="line"></div><div class="line">//现在直接</div><div class="line">std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h3><p>之前模板只在使用的时候被实例化，就是碰到了完整定义的模板都会实例化。c11加入了外部模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template class std::vector&lt;MagicClass&gt;; // 强行实例化</div><div class="line">extern template class std::vector&lt;MagicClass&gt;; // 不在该编译文件中实例化</div></pre></td></tr></table></figure></p>
<h3 id="using-类型别名"><a href="#using-类型别名" class="headerlink" title="using 类型别名"></a>using 类型别名</h3><p>和typedef 一样，但是还可以定义与模板的类型名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int (*process)(void *); // 定义了一个返回类型为 int，参数为</div><div class="line">void* 的函数指针类型，名字叫做 process</div><div class="line">using process = void(*)(void *); // 同上, 更加直观</div><div class="line">using NewType = SuckType&lt;std::vector, std::string&gt;;</div></pre></td></tr></table></figure></p>
<h3 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T = int, typename U = int&gt;</div><div class="line">auto add(T x, U y) -&gt; decltype(x+y) &#123;</div><div class="line">return x+y</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h3><p><code>template&lt;typename... Args&gt; class Test</code></p>
<p>递归解包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">template&lt;typename T&gt;</div><div class="line">void printf(T value) </div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line">template&lt;typename T, typename... Args&gt;</div><div class="line">void printf(T value, Args... args)</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</div><div class="line">    printf(args...);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    printf(1, 2, &quot;123&quot;, 1.1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h2><p>同一个类里面一个构造函数调用另外一个构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Base </div><div class="line">&#123;</div><div class="line"></div><div class="line">Base() &#123; value1 = 1; &#125;</div><div class="line">Base(int value) : Base()</div><div class="line">&#123; // 委托 Base() 构造函数</div><div class="line">    value2 = 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public:</div><div class="line">    int value1;</div><div class="line">    int value2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Subclass : public Base</div><div class="line"> &#123;</div><div class="line">public:</div><div class="line">    using Base::Base; // 继承构造</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>当重载虚函数时，override会显示告知编译器检查父类有没有这样的函数，没有会编译不过。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final 防止被继承的函数重载</p>
<h2 id="显示禁用默认函数"><a href="#显示禁用默认函数" class="headerlink" title="显示禁用默认函数"></a>显示禁用默认函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Magic </div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Magic() = default; // 显式声明使用编译器生成的构造</div><div class="line">    Magic&amp; operator=(const Magic&amp;) = delete; // 显式声明拒绝编译器生成构造</div><div class="line">    Magic(int magic_number);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum class new_enum:unsigned int</div><div class="line">&#123;</div><div class="line">    ETYPE1,</div><div class="line">    ETYPE2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要是这么定义的枚举不会像以前那样被隐式转换了。</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p><a href=""></a>{}定义。。。<br>[]是捕获列表，[var1, var2]捕获变量，[&amp;]按引用捕获，[=]按值捕获</p>
<h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p>我的理解就是一个函数对象</p>
<h2 id="std-bind-std-placeholder"><a href="#std-bind-std-placeholder" class="headerlink" title="std::bind / std:placeholder"></a>std::bind / std:placeholder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int fun(int a, int b, int c)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">auto fun = std::bind(fun, std::placeholders::_1, 1, 2)</div><div class="line"></div><div class="line">fun(999); //相当于 fun(999, 1, 2);</div></pre></td></tr></table></figure>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>###左值(lvalue, left value)<br>顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p>
<p>###右值(rvalue, right value)<br>赋值符号右边的值，是指表达式结束后就不再存在的临时对象。</p>
<p>###纯右值(prvalue, pure rvalue)<br>纯粹的右值，要么是纯粹的字面量，例如 10 ,true ；要么是求值结果相当于字面量或匿名临时对象，例如 1+2 。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。</p>
<p>###将亡值(xvalue, expiring value)<br>是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中，纯右值和右值是统一个概念），也就是即将被销毁、却能够被移动的值。</p>
<p>右值引用的申明 T &amp;&amp;<br>std::move 这个方法将左值参数无条件的转换为右值</p>
<p>移动语义<br>之前的类拷贝是创一个新的然后塞过去。就导致一个循环会创很多临时变量<br>用移动语义会拿到将亡值，然后直接拷贝内存。就不用创新的了。</p>
<p>模板函数中使用 T&amp;&amp; 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。</p>
<h2 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h2><p>std::array 是封装固定大小数组的容器。<br>std::array<int, 3=""> a = {1,2,3};<br>std::array 保存在栈内存,std::vector保存在堆内存。</int,></p>
<h2 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h2><p>和std::list差不多。不过是单向的</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>std::unordered_map / std::unordered_multimap 和std::unordered_set / std::unordered_multiset 。<br>内部是Hash实现的。复杂度是O(constant)</p>
<h2 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h2><p>类模板 std::tuple 是固定大小的异类值汇集</p>
<ol>
<li>std::make_tuple : 构造元组</li>
<li>std::get : 获得元组某个位置的值</li>
<li>std::tie : 元组拆包</li>
</ol>
<p>RAII全称为Resource Acquisition Is Initialization 资源获取就是初始化</p>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>只能指针，，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示的调用 delete ，当引用计数变为零的时候就会将对象自动删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::shared_ptr pointer = std::make_shared&lt;int&gt;(10);</div><div class="line">std::shared_ptr&lt;int&gt; pointer2 = pointer; //计数+1</div></pre></td></tr></table></figure></p>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>独占的智能指针，它禁止其他智能指针与其共享同一个对象。可以使用std::move 将其转移给其他的 unique_ptr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::unique_ptr&lt;int&gt; pointer = std::make_unique&lt;int&gt;(10); </div><div class="line">std::unique_ptr&lt;int&gt; pointer2 = pointer;  //非法</div></pre></td></tr></table></figure></p>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p> std::weak_ptr 用来表达临时所有权的概念：当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用 std::weak_ptr 来跟踪该对象。需要获得临时所有权时，则将其转换为 std::shared_ptr，此时如果原来的 std::shared_ptr 被销毁，则该对象的生命期将被延长至这个临时的 std::shared_ptr 同样被销毁为止。</p>
<h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p>用于创建一个执行的线程实例</p>
<h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>互斥量，通过其成员函数 lock() 可以仅此能上锁， unlock() 可以进行解锁。配合std::lock_gurad 使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void some_operation(const std::string &amp;message)</div><div class="line"> &#123;</div><div class="line">    static std::mutex mutex;</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex);</div><div class="line">    // ...操作</div><div class="line">    // 当离开这个作用域的时候，互斥锁会被析构，同时unlock互斥锁</div><div class="line">    // 因此这个函数内部的可以认为是临界区</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>std::unique_lock 独占权管理mutex</p>
<p>std::future, std::packaged_task 异步操纵结果</p>
<p>std::condition_variable 条件竞争</p>
<p><a href="https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details" target="_blank" rel="external">其实也没怎么用过，详细要看这个</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/08/09/RealTimeRendering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/09/RealTimeRendering/" itemprop="url">渲染管线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T11:06:01+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图像渲染管线"><a href="#图像渲染管线" class="headerlink" title="图像渲染管线"></a>图像渲染管线</h1><p>渲染管线我的理解就是把渲染的过程分为多个阶段，这样就不用等一个完整的流程好了再进行下一次，就像工厂流水线一样，只要关注当前的这个阶段就好了。</p>
<p>Real Time Rendering把图形渲染管线分为三个阶段：</p>
<ul>
<li>The Application Stage</li>
<li>The Geometry Stage</li>
<li>The Rasterizer Stage</li>
</ul>
<h2 id="The-Application-Stage-应用程序阶段"><a href="#The-Application-Stage-应用程序阶段" class="headerlink" title="The Application Stage 应用程序阶段"></a>The Application Stage 应用程序阶段</h2><p>在直接调用硬件图形接口之前，程序员通过软件代码的实现，比如碰撞检测啊，加速算法什么的处理。</p>
<h2 id="The-Geometry-Stage-几何阶段"><a href="#The-Geometry-Stage-几何阶段" class="headerlink" title="The Geometry Stage 几何阶段"></a>The Geometry Stage 几何阶段</h2><p>几何阶段主要对顶点和多边形进行操作。这个阶段可以划分成如下几个功能：</p>
<ol>
<li>模型视点变换：模型坐标 -&gt; 世界坐标 -&gt; 观察坐标</li>
<li>顶点着色：对模型的顶点进行着色计算，根据点的位置，法线，颜色，计算光照，材质什么的</li>
<li>投影： 正交/透视投影，把三维的空间投射到二维空间里</li>
<li>裁剪： 裁剪掉不在视体内部的部分。</li>
<li>屏幕映射 虽然投影完视图变成了二维的，但是坐标系还是3维的，所以要转换成屏幕坐标系</li>
</ol>
<h2 id="The-Rasterizer-Stage-光栅化阶段"><a href="#The-Rasterizer-Stage-光栅化阶段" class="headerlink" title="The Rasterizer Stage 光栅化阶段"></a>The Rasterizer Stage 光栅化阶段</h2><p>光栅化就是把顶点数据转换为片元的过程，片元中的每一个元素对应于帧缓冲区中的一个像素。</p>
<ol>
<li>三角形设定阶段 计算三角形的表面数据</li>
<li>三角形遍历 检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成片段。</li>
<li>像素着色 计算所有需逐像素操作的过程。纹理贴图啊，插值计算啊什么的。</li>
<li>融合 合成当前储存于缓冲器（深度，模板，alpha缓冲器）中的由之前的像素着色阶段产生的片段颜色。 </li>
</ol>
<h1 id="GPU渲染管线"><a href="#GPU渲染管线" class="headerlink" title="GPU渲染管线"></a>GPU渲染管线</h1><p>GPU实现的渲染管线和上面的有一点差异：</p>
<h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><ul>
<li><p>顶点着色器（The Vertex Shader）的功能于2001年首次在DirectX 8中引入。由于它是流水线上的第一个阶段，可选是在GPU还是CPU上实现。而在CPU上实现的话，需将CPU中的输出数据发送到GPU进行光栅化。目前几乎所有的GPU都支持顶点着色。</p>
</li>
<li><p>顶点着色器是完全可编程的阶段，是专门处理传入的顶点信息的着色器，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作。顶点着色器一般不处理附加信息，也就是说，顶点着色器提供了修改，创建，或者忽略与每个多边形顶点相关的值的方式，例如其颜色，法线，纹理坐标和位置。通常，顶点着色器程序将顶点从模型空间（Model Space）变换到齐次裁剪空间（Homogeneous Clip Space），并且，一个顶点着色器至少且必须输出此变换位置。</p>
</li>
<li><p>值得注意的是，在这个顶点着色阶段之前发生了一些数据操作。比如在DirectX中叫做输入装配（Input Assembler）的阶段，会将一些数据流组织在一起，以形成顶点和基元的集合，发送到管线。<br>顶点着色器本身与前面3.2节所述的通用核心虚拟机（Common-Shader Core Virtual Machine）非常相似。传入的每个顶点由顶点着色器程序处理，然后输出一些在三角形或直线上进行插值后获得的值。顶点着色器既不能创建也不能消除顶点，并且由一个顶点生成的结果不能传递到另一个顶点。由于每个顶点都被独立处理，所以GPU上的任何数量的着色器处理器都可以并行地应用到传入的顶点流上。</p>
</li>
<li><p>顶点着色器的输出可以以许多不同的方式来使用，通常是随后用于每个实例三角形的生成和光栅化，然后各个像素片段被发送到像素着色器，以便继续处理。而在Shader Model 4.0中，数据也可以发送到几何着色器（Geometry Shader）或输出流（Streamed Output）或同时发动到像素着色器和几何着色器两者中。</p>
</li>
</ul>
<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>允许GPU高效地创建和销毁几何图元（点、线、三角），几何着色器是可选的，完全可编程的阶段。</p>
<ul>
<li><p>几何着色器（Geometry Shader）是顶点和片段着色器之间一个可选的着色器，随着2006年底 DirectX10的发布被加入到硬件加速图形管线中。几何着色器作为Shader Model 4.0的一部分，不能早期着色模型（&lt;=SM 3.0）中使用。</p>
</li>
<li><p>几何着色器可以改变新传递进来的图元的拓扑结构，且几何着色器可以接收任何拓扑类型的图元，但是只能输出点、折线（line strip）和三角形条（triangle strips）。</p>
</li>
<li><p>几何着色器需要图元作为输入，在处理过程中他可以将这个图元整个丢弃或者输出一个或更多的图元（也就是说它可以产生比它得到的更多或更少的顶点）。这个能力被叫做几何增长（growing geometry）。如上所述，几何着色器输出的形式只能是点，折线和三角形条。</p>
</li>
<li><p>当我们未添加几何着色器时，默认的行为是将输入的三角形直接输出。我们添加了几何着色器之后，可以在几何着色器中修改输出的图形，我们可以输出我们想要输出的任何图形。</p>
</li>
</ul>
<h2 id="像素着色器"><a href="#像素着色器" class="headerlink" title="像素着色器"></a>像素着色器</h2><ul>
<li><p>像素着色器(Pixel Shader，Direct3D中的叫法)，常常又称为片断着色器,片元着色器(Fragment Shader, OpenGL中的叫法)，用于进行逐像素计算颜色的操作，让复杂的着色方程在每一个像素上执行。在顶点和几何着色器执行完其操作之后，图元会被裁剪、屏幕映射，结束几何阶段，到达光栅化阶段，在光栅化阶段中先经历三角形设定和三角形遍历，之后来到像素着色阶段。</p>
</li>
<li><p>像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片断着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片断着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。</p>
</li>
<li><p>需要注意，像素着色程序通常在最终合并阶段设置片段颜色以进行合并，而深度值也可以由像素着色器修改。模板缓冲（ stencil buﬀer ）值是不可修改的，而是将其传递到合并阶段（merge stage）。在SM 2.0以及以上版本，像素着色器也可以丢弃（discard ）传入的片段数据，即不产生输出。这样的操作会消耗性能，因为通常在这种情况下不能使用由GPU执行的优化。</p>
</li>
<li><p>可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在Shader Model 4.0中，共有16个向量（每个向量含4个值）可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出32个向量到像素着色器中。像素着色器的追加输入是在Shader Model 3.0中引入的。例如，三角形的哪一面是可见的是通过输入标志来加入的。这个值对于在单个通道中的正面和背面渲染不同材质十分重要。而且像素着色器也可以获得片段的屏幕位置。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/07/20/dx11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/20/dx11/" itemprop="url">dx11学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T10:43:37+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>最近老是查一些显存的内存泄漏问题，因为ue4在pc上的rhi基本上都是dx实现，有很多看的不是很懂的地方，感觉需要学习一下这玩意。</p>
<h1 id="Direct3d"><a href="#Direct3d" class="headerlink" title="Direct3d"></a>Direct3d</h1><p>官网的介绍是</p>
<blockquote>
<p>Direct3D is a low-level API that you can use to draw triangles, lines, or points per frame, or to start highly parallel operations on the GPU.</p>
</blockquote>
<p>其实就是一组操作图像的api。。</p>
<h1 id="DXGI"><a href="#DXGI" class="headerlink" title="DXGI"></a>DXGI</h1><p>Microsoft DirectX Graphics Infrastructure (DXGI)，我的理解就是一个位于Direct3d和硬件的中间层，查了一下说是，因为dx不停的升级，每个版本有很多能共享的代码，放到这里面来管理了。</p>
<h1 id="The-Swap-Chain"><a href="#The-Swap-Chain" class="headerlink" title="The Swap Chain"></a>The Swap Chain</h1><p>因为显示器刷新没有gpu快，所以会有一个交换链的机制用于渲染，就是两块缓存区域，当前显示的时候，可能后台下一帧已经准备好了。</p>
<h1 id="ID3D11Device"><a href="#ID3D11Device" class="headerlink" title="ID3D11Device"></a>ID3D11Device</h1><p>In Direct3D, a device is an object that is intended to be a virtual representation of your video adapter. 应该是显卡的抽象，用来创建资源。</p>
<h1 id="ID3D11DeviceContext"><a href="#ID3D11DeviceContext" class="headerlink" title="ID3D11DeviceContext"></a>ID3D11DeviceContext</h1><p>A device context is similar to a device, but it is responsible for managing the GPU and the rendering pipeline (the device mostly handles video memory). This object is used to render graphics and to determine how they will be rendered.<br>主要是用来管理gpu渲染流程。</p>
<h1 id="IDXGISwapChain"><a href="#IDXGISwapChain" class="headerlink" title="IDXGISwapChain"></a>IDXGISwapChain</h1><p>就是刚才说的交换链的抽象，用来交换前后台的缓存的buffer</p>
<h1 id="DXGI-SWAP-CHAIN-DESC"><a href="#DXGI-SWAP-CHAIN-DESC" class="headerlink" title="DXGI_SWAP_CHAIN_DESC"></a>DXGI_SWAP_CHAIN_DESC</h1><p>交换链的描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef struct DXGI_SWAP_CHAIN_DESC</div><div class="line">    &#123;</div><div class="line">    DXGI_MODE_DESC BufferDesc;</div><div class="line">    DXGI_SAMPLE_DESC SampleDesc; //采样</div><div class="line">    DXGI_USAGE BufferUsage;</div><div class="line">    UINT BufferCount;  //后台缓冲区数量</div><div class="line">    HWND OutputWindow;  </div><div class="line">    BOOL Windowed;</div><div class="line">    DXGI_SWAP_EFFECT SwapEffect;</div><div class="line">    UINT Flags;</div><div class="line">    &#125; 	DXGI_SWAP_CHAIN_DESC;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/26/insideC-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/insideC-3/" itemprop="url">InsideC++笔记 Function语义学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T15:32:05+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Function-语义学"><a href="#Function-语义学" class="headerlink" title="Function 语义学"></a>Function 语义学</h1><h2 id="非静态成员函数-NonStatic-Member-Functions"><a href="#非静态成员函数-NonStatic-Member-Functions" class="headerlink" title="非静态成员函数  NonStatic Member Functions"></a>非静态成员函数  NonStatic Member Functions</h2><p>调用非静态成员函数的时候没有额外的开销，因为编译器会把非静态成员函数转换为一个局部函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//非成员函数</div><div class="line">float magnitude3d(const Point3d *_this)&#123;...&#125;</div><div class="line">//成员函数</div><div class="line">float Point3d::magnitude3d()const&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>编译器对非静态成员函数的操作:<br>1.改写函数签名，把this指针插入到函数中</p>
<blockquote>
<p>float Point3d::magnitude3d(Point3d *const this)</p>
</blockquote>
<p>2.把所有的非静态成员数据改成用this指针调用<br>3.把成员函数的名字改成一个独一无二的名称</p>
<blockquote>
<p>extern magnitude_7Point3dFv(regiser Point3d *const this);</p>
</blockquote>
<p>4.把所有函数调用的地方替换了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj.magnitude(); // magnitude_7Point3dFv(&amp;obj);</div><div class="line">ptr-&gt;magnitude(); // magnitude_7Point3dFv(ptr);</div></pre></td></tr></table></figure></p>
<h2 id="虚函数-Virtual-Member-Functions"><a href="#虚函数-Virtual-Member-Functions" class="headerlink" title="虚函数 Virtual Member Functions"></a>虚函数 Virtual Member Functions</h2><p>如果normalize声明为虚函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;normalize(); // (*ptr-&gt;vptr[1](ptr);</div><div class="line">obj.normalize(); // (* obj.vptr[1])(&amp;obj);</div></pre></td></tr></table></figure></p>
<p>因为obj的调用方式说明他不支持多态，所以这个调用会想非静态成员函数一样转换为</p>
<blockquote>
<p>normalize_7Point3dFv(&amp;obj);</p>
</blockquote>
<h2 id="静态成员函数Static-member-function"><a href="#静态成员函数Static-member-function" class="headerlink" title="静态成员函数Static  member function"></a>静态成员函数Static  member function</h2><p>因为这货没有this指针，所以基本上跟非成员函数差不多。</p>
<h1 id="Virtual-Member-Functions-虚函数"><a href="#Virtual-Member-Functions-虚函数" class="headerlink" title="Virtual Member Functions 虚函数"></a>Virtual Member Functions 虚函数</h1><h2 id="单继承下的虚函数"><a href="#单继承下的虚函数" class="headerlink" title="单继承下的虚函数"></a>单继承下的虚函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prt-&gt;z();</div></pre></td></tr></table></figure>
<p>如果z是一个虚函数，那么执行期是如何正确调用z的呢？</p>
<h3 id="虚函数实现的机制"><a href="#虚函数实现的机制" class="headerlink" title="虚函数实现的机制"></a>虚函数实现的机制</h3><p>首先多态对象会增加两个成员</p>
<ol>
<li>一个字符串或数字表示clas的类型，</li>
<li>一个指针，指针指向一个表格，表格是所有虚函数的执行期地址。<br>为每个虚函数分配一个索引，用来查找在表格中的位置。</li>
<li>继承类继承派生类的所有虚函数表，</li>
<li>如果继承类里面有个override了虚函数的，就要在对应索引位置用重写的函数地址覆盖。</li>
<li>派生类可以加入新的虚函数</li>
</ol>
<h2 id="多重继承下的虚函数"><a href="#多重继承下的虚函数" class="headerlink" title="多重继承下的虚函数"></a>多重继承下的虚函数</h2><p>多重继承结构下，基本上继承几个就有几个虚函数表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Base1</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Base1();</div><div class="line">	virtual ~Base1();</div><div class="line">	virtual void func1();</div><div class="line">	virtual void Base1 *clone() const;</div><div class="line">protected:</div><div class="line">	float data_base1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Base2</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Base2();</div><div class="line">	virtual ~Base2();</div><div class="line">	virtual void func2();</div><div class="line">	virtual void Base2 *clone() const;</div><div class="line">protected:</div><div class="line">	float data_base2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">class Derived: public Base1, public Base2</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Derived();</div><div class="line">	virtual ~Derived();</div><div class="line">	virtual void Derived *clone() const;</div><div class="line">protected:</div><div class="line">	float data_Derived;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上面的继承结构Derived类，继承了Base1,Base2<br>Base1的虚函数表结构：</p>
<blockquote>
<p>[0] Base1::~Base1()<br>[1] Base1::func1()<br>[2] Base1::clone()</p>
</blockquote>
<p>Base2的虚函数表结构：</p>
<blockquote>
<p>[0] Base2::~Base2();<br>[1] Base2::func2();<br>[2] Base2::clone();</p>
</blockquote>
<p>Derived会产生两个虚函数表:<br>_vptr_Base1的结构</p>
<blockquote>
<p>[0] Derived::~Derived()<br>[1] Base1::func1()<br>[2] Derived::clone()<br>[3] Base2::func2()</p>
</blockquote>
<p>_vptr_Base2的结构</p>
<blockquote>
<p>[0] Derived::~Derived()<br>[1] Base2::func2()<br>[2] Derived::clone()</p>
</blockquote>
<h2 id="虚拟继承下的虚函数"><a href="#虚拟继承下的虚函数" class="headerlink" title="虚拟继承下的虚函数"></a>虚拟继承下的虚函数</h2><p>当菱形继承结构时,用虚继承，是为了避免重复拷贝，所以会保存一份副本。<br>如A派生出B、C 又D虚继承与B,C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;</div><div class="line">class B:public A&#123;&#125;</div><div class="line">class C:public A&#123;&#125;</div><div class="line">class D:public virtual B, public virtual C&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候D的结构会有B的虚函数表，C的虚函数表，还有共享的A的虚函数表<br>要注意的是多重继承，且虚继承的时候，最上次的基类中最好不要定义成员数据。</p>
<h2 id="内联函数-inline-function"><a href="#内联函数-inline-function" class="headerlink" title="内联函数 inline function"></a>内联函数 inline function</h2><p>设置inline只是一个请求，实际是否为内联函数是由编译器决定的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">inline int bar()</div><div class="line">&#123;</div><div class="line">	int minval;</div><div class="line">	int val1 = 1024;</div><div class="line">	int val2 = 2048;</div><div class="line"></div><div class="line">	minval = min(val1, val2);     // 1</div><div class="line">	minval = min(1024, 2048); 	  // 2</div><div class="line">	minval = min(foo(), bar()+1); //3 </div><div class="line">	return minval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>情况1 参数直接代换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minval = val1 &lt; val2 ? val2 : val2;</div></pre></td></tr></table></figure></p>
<p>情况2 直接使用常量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minval = 1024；</div></pre></td></tr></table></figure></p>
<p>情况3 为避免重复求值会导入一个临时对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int t1,t2;</div><div class="line">minval = (t1=foo()), (t2=bar()+1), t1&lt;t2?t1:t2;</div></pre></td></tr></table></figure></p>
<p>如果在inline定义里面加入一个局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">inline int min(int i, int j)</div><div class="line">&#123;</div><div class="line">	int local_val;</div><div class="line">	int mainval;</div><div class="line">	...</div><div class="line">	minval = min(vall1, val2); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般而言，inline函数里面的每个局部变量都会放在函数的一个封闭区域内，且被设成一个独一无二的名字。<br>所以要注意的是滥用含局部变量，且有副作用参数加入临时对象的情况，会导致程序的扩张。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/19/insideC-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/19/insideC-2/" itemprop="url">InsideC++笔记 Data语义学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T11:01:38+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="虚基类继承时的内存分布对象"><a href="#虚基类继承时的内存分布对象" class="headerlink" title="虚基类继承时的内存分布对象"></a>虚基类继承时的内存分布对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class X&#123;&#125;;</div><div class="line">class Y:public virtual X&#123;&#125;;</div><div class="line">class Z:public virtual X&#123;&#125;;</div><div class="line">class A:public Y, public Z&#123;&#125;;</div></pre></td></tr></table></figure>
<p>使用sizeof之后<br>size X = 1<br>size Y = 8(vc++下等于4)<br>size Z = 8(vc++下等于4)<br>size A = 12(vc++下等于8)</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>sizeof(X)时，虽然什么都没有，但是编译器会安插一个char类型保证对象的内存地址独一无二。所以sizeof(x)==1</li>
<li>对于类Y和Z，因为虚继承了X,编译器就会自己生成一个指针指向虚基类或者指向一个表格，表格里面存放着虚基类的地址或者偏移量。所以此时的Y,Z的大小就是指针的大小加上X的大小就等于5个bytes。然后在被内存对齐就是8bytes了<br><em>为什么vc++下面，Y,Z大小是4？</em><br>因为X是空的虚基类，在一些编译器下面就被优化了。一个空的虚基类会被看成派生类的开头部分,所以就节省了那个1个bytes，所以大小为4bytes</li>
<li>对于A的大小，需要注意的是无论同一个虚基类被继承了多少次，只会有一个实体。所以A的大小就是1+8等于9bytes然后再对齐一下就变成了12bytes。同理vc++编译器下是8个bytes</li>
</ol>
<h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>编译器会把一个以上的access section(public, private, protect)连锁在一起，所以定义多个sections不消耗额外的性能。access level中的member的排列次序必须和声明的次序相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Point3d</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	virtual ~Point3d();</div><div class="line">private:</div><div class="line">	static 	Point3d origin;</div><div class="line">	float x, y, z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>取某个坐标成员的地址 &amp;Point3d::z，等价于z坐标在class Point3d中的偏移量offset。</p>
<h3 id="编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？"><a href="#编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？" class="headerlink" title="编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？"></a>编译器如何区别一个指向没有任何数据成员的指针，和指向第一个数据成员的指针？</h3><p>float Point3d::<em>p1 = 0;<br>float Point3d::</em>p2  = &amp;Point3d::x;<br>为了让编译器能区别上面两个指针，每个member的offset都会加1，这时候如果两个值相等，那说明他们肯定指向同一个数据成员。</p>
<h3 id="两种存取方式"><a href="#两种存取方式" class="headerlink" title="两种存取方式"></a>两种存取方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Point3d Origin, *pt = &amp;origin;</div><div class="line">origin.X = 0.0;</div><div class="line">pt-&gt;x = 0.0;</div></pre></td></tr></table></figure>
<p>所以对于这两种存取方式的效率问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">origin.x = 0.0F;        // 等价于 *(&amp;origin + (&amp;Point3d::x - 1)) = 0.0;</div><div class="line">pt-&gt;x = 0.0F;           // 等价于 *(pt + (&amp;Point3d::x - 1)) = 0.0;</div></pre></td></tr></table></figure></p>
<p>最大的问题在于Point3d的不确定性，如果他是一个派生类,而X是继承而来的。所以编译器是不知道Pt中X的offset,但是Origin则肯定是Point3d类型了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/15/InsideC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/InsideC/" itemprop="url">InsideC++笔记 构造函数篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-15T18:44:05+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h1><h2 id="Default-Constructor"><a href="#Default-Constructor" class="headerlink" title="Default Constructor"></a>Default Constructor</h2><h3 id="编译器生成默认构造函数"><a href="#编译器生成默认构造函数" class="headerlink" title="编译器生成默认构造函数"></a>编译器生成默认构造函数</h3><ul>
<li>类里面有一个member object,且该对象有一个默认构造函数，如果有一个以上的成员对象，会按成员对象声明的顺序，依次调用每个构造函数的。</li>
<li>类的基类有默认构造函数</li>
<li>类或基类的成员函数有虚函数</li>
<li>类的基类有Virtual Base Calss</li>
</ul>
<p>所以说并不是所有的类没有定义默认构造函数，编译器就会自己生成一个！！</p>
<h2 id="Copy-Constructor"><a href="#Copy-Constructor" class="headerlink" title="Copy Constructor"></a>Copy Constructor</h2><h3 id="三个调用的情况"><a href="#三个调用的情况" class="headerlink" title="三个调用的情况"></a>三个调用的情况</h3><p>作为初始化赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class X &#123;...&#125;;</div><div class="line">X x;</div><div class="line">X xx = x;</div></pre></td></tr></table></figure></p>
<p>作为函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern void foo(X x);</div><div class="line">void bar</div><div class="line">&#123;</div><div class="line"> X xx;</div><div class="line"> foo(xx);	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作为返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">X func()</div><div class="line">&#123;</div><div class="line"> X xx;</div><div class="line"> ...</div><div class="line"> return xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h3><p>当没有显示定义拷贝构造函数的时候，用一个相同的对象作为另一个对象的初始值，就会以递归的方式，把成员数据一个一个赋值上去。碰到成员是class，就进入这个class再一个一个拷贝class的成员数据。</p>
<h3 id="BitWise-Copy-Semantics-位逐次拷贝"><a href="#BitWise-Copy-Semantics-位逐次拷贝" class="headerlink" title="BitWise Copy Semantics 位逐次拷贝"></a>BitWise Copy Semantics 位逐次拷贝</h3><p>上述的Default Memberwise Initialization只在符合BitWise Copy Semantics的情况下才会实行。<br>不符合BitWise Copy Semantics 的情况：</p>
<ul>
<li>class的数据成员里面有定义了Copy Constructor的object</li>
<li>class的基类里面有定义Copy Constructor</li>
<li>class定义了虚函数</li>
<li>class有一个或多个虚基类</li>
</ul>
<p><strong>为什么不能有虚函数？</strong><br>因为可能会拷贝vptr，而导致一些错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">virtual void func()</div><div class="line">&#125;;</div><div class="line">class B:A</div><div class="line">&#123;</div><div class="line">virtual void func();</div><div class="line">&#125;;</div><div class="line">B b1;</div><div class="line">B b2 =b1;</div><div class="line">A a = b1; </div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>因为用b1初始化a的过程，会产生截断，如果采用位逐次拷贝的话，会把B的虚函数表拷完全拷给A，这时候要是A调用虚函数，可能会发生错误。</p>
<p><strong>为什么不能有虚基类？</strong><br>我的理解是编译器无法知道要开拷贝的这个对象是该对象本身还是一个指向基类的对象。</p>
<h2 id="Named-Return-Value优化"><a href="#Named-Return-Value优化" class="headerlink" title="Named Return Value优化"></a>Named Return Value优化</h2><p>对于代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void function()</div><div class="line">&#123;</div><div class="line">	X x1(x0);</div><div class="line">	X x2 = x0;</div><div class="line">	x x3 =X(x0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会被程序转换成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void function()</div><div class="line">&#123;</div><div class="line">	X x1;</div><div class="line">	X x2;</div><div class="line">	X x3;</div><div class="line"></div><div class="line">	//X::X(const X&amp;xx)</div><div class="line">	x1.X::X(x0);</div><div class="line">	x2.X::X(x0);</div><div class="line">	x3.X::X(x0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">X func()</div><div class="line">&#123;</div><div class="line"> X xx;</div><div class="line"> ...</div><div class="line"> return xx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会变成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void func(X&amp; __result)</div><div class="line">&#123;</div><div class="line">	X xx;</div><div class="line">	xx.X::X();</div><div class="line">	...</div><div class="line">	__result.X::X(xx);</div><div class="line">	return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过对于函数和对象复杂的时候这种优化会坑爹。。。</p>
<h2 id="成员初始化列表-Member-Initialization-List"><a href="#成员初始化列表-Member-Initialization-List" class="headerlink" title="成员初始化列表 Member Initialization List"></a>成员初始化列表 Member Initialization List</h2><p>使用情况</p>
<ul>
<li>当初始化一个reference member时</li>
<li>当初始化一个const member时</li>
<li>当调用一个base class 的constructor,而它拥有一组参数</li>
<li>当调用一个member class的constructor，而它拥有一组参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">	String Name;</div><div class="line">	int cnt;</div><div class="line">public:</div><div class="line">	A()&#123;</div><div class="line">		Name = 0;</div><div class="line">		cnt  = 0;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这种写法本身是没毛病，但是Name是个对象，上面的代码就会扩张成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A::A()</div><div class="line">&#123;</div><div class="line">  Name.String::String();</div><div class="line">  String temp = String(0);</div><div class="line">  Name.String::operate=(temp);</div><div class="line">  temp.String::~String();</div><div class="line"></div><div class="line">  cnt = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以更好的写法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A::A</div><div class="line">:Name(0)</div><div class="line">&#123;</div><div class="line">	cnt = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那问题来了，所有的成员都用列表初始化么。<br>对于以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	int j;</div><div class="line">public:</div><div class="line">  A(int val)</div><div class="line">  :j(val)</div><div class="line">  ,i(j)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为初始化列表会按定义的属性初始化，所以先是i被j赋值，然后j才被val赋值，这时候i就会是个未定义的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A::A(int val)</div><div class="line"> : j(val)</div><div class="line">&#123;</div><div class="line"> 	i = j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这种代码i还是未定义的，因为初始化列表总是在大括号执行完之后才执行的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.hhhhyf.com/2017/06/14/设计稿(第一版)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sylar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sylar's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/14/设计稿(第一版)/" itemprop="url">设计稿(第一版)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-14T17:24:51+08:00">
                2017-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/游戏/" itemprop="url" rel="index">
                    <span itemprop="name">游戏</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>一直想做个自己觉得有意思的游戏，但是因为太懒，一直没有行动起来。最近的项目用的是Unreal引擎，但是接触引擎的大部分都是场景部分的模块，对角色动画，AI完全不了解，希望这个demo能学习一下这方面的知识，也能圆了自己一个小小的愿望。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>构思中的游戏是一个魔法世界的背景，主角在一个魔法塔里面。开始是一个新手学徒，然后通过完成老师的各种任务，完成魔法塔周围的地下城，成为牛逼大法师的狗血故事。</p>
<h1 id="培养"><a href="#培养" class="headerlink" title="培养"></a>培养</h1><p>希望能做成一个养成游戏，披着魔法外壳的牧场物语，通过培养角色的属性，体验慢慢成长的乐趣。战斗可能只是去收集材料，大部分时间是在魔塔里面的。 </p>
<h1 id="核心系统"><a href="#核心系统" class="headerlink" title="核心系统"></a>核心系统</h1><h2 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h2><ul>
<li>时间类型 时间流逝会对世界造成影响。</li>
<li>角色属性 待设计</li>
<li>魔法类型 待设计</li>
<li>战斗系统 希望能做成上古卷轴，巫师那种战斗模式吧。</li>
</ul>
<h2 id="次要"><a href="#次要" class="headerlink" title="次要"></a>次要</h2><ul>
<li>药剂学 需要有一个种菜系统，和一个炼药系统。</li>
<li>炼金学 需要一个抓怪物的系统，和培养怪物的系统。</li>
</ul>
<h1 id="地下城"><a href="#地下城" class="headerlink" title="地下城"></a>地下城</h1><p>地下城的可能有怪物，也可能是跳机关陷阱，可也能是解密。是所有材料，宝物产出的地方。</p>
<h1 id="多人联机"><a href="#多人联机" class="headerlink" title="多人联机"></a>多人联机</h1><p>待定</p>
<p>…………………………………………………………………………………….<br>2017-7-4 总结<br>花了两个周末，完成了人物的基本逻辑，动作行为状态机，行走跑跳攻击，连击。主要的问题在于动作连贯表现不是很好。不过对UE4动画系统那一套 基本上搞明白了怎么用。<br>然后又研究了ai系统，实现了一个简单的怪物巡逻，然后发现主角了会自己过来攻击的逻辑。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Sylar" />
          <p class="site-author-name" itemprop="name">Sylar</p>
           
              <p class="site-description motion-element" itemprop="description">You have a dream, you gotta to protect it.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sylar</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
